## Overview of design:
 Our design is primarily based on the Single Responsibility Principle when it comes to the classes. Each class has the responsibility of handling a different object or being a controller to an object. For example, Gesture and NoteBar, inherit from our abstract SoundObject class so that each class handles a gesture or a notebar instead of having a class that handles both (such as a concrete SoundObject class). We also used inheritance to make our code elegant. In addition to the SoundObject inheritance relation, we created a package that holds all of our different action classes that all inherit from an abstract Action class. These action classes are how we implemented the undo, redo, cut and paste functions for our program, where each one handles a single type of undo-able action. We also implemented the undo/redo function to follow the Open/Closed Principle. This function is open for extension and closed for modification becasue, if we create more undo-able actions we can easily create another action class for it by implementing it with the abstract Action class. This came in handy for this project when we implemented the cut, copy and paste actions.

We also seperated our classes with Controllers in order to follow the guideline that states that "different kinds of responsibilities should be seperated among different objects" (Skrien 141). This allows a class like NoteBar to handle only its properties and not the properties/modifications that are given to it through the composition pane such as interactions with other note bars. Our implementation of Actions also takes this guideline into account. Each action class has as different responsibility and are seperated into different classes that share the Action abstract class. Some examples are AddNoteAction, GroupAction, MoveAction and SelectAction.

We take into account the Law of Demeter in our design. In our SoundObject class, we created a method, getAllRelated() that gets all of the children from the top gesture of the SoundObject instead of calling something like "this.getTopGesture().getAllChildren()." We also see this with our method unselectTopGesture() that replaces "this.getTopGesture().unselect()."

Our methods are cohesive and follow the guideline of doing one thing and doing it well. We also follow the guideline that states that :methods which return a value should not modify any existing object's state" (Skrien 89). We also use naming conventions for methods and fields that are consistent and intention-revealing.

In Project 7, our project was expanded to use the Observer/Observable pattern in order to access changes to the pane in order to access the correct moments to disable menu items. This pattern allows our top-down nesting of controllers to access changes made to contained panes in order to set the disabling in the Application Controller, or outer-most layer of the panes. We further expanded the project by building off of our Action class structure to include Cut, Copy and Paste. Cut makes use of combining Copy and Paste into a single action while these two new methods use a dedicated parser class in order to store and use the system clipboard to impliment traditional cut, copy and paste features. In responding to feedback, we ensured full implimentation of disabling.

In Project 8, we expand our current design to include New, Open, Save, SaveAs and About. This design is primarily implimented through the use of a nested inner class in Application Controller and the addition of a FileManager class. These are called within Application.fxml and contain a succint path of classes which impliment these new features. This new design uses our previous ability to read a text version of the contents of our screen, dealt with in Copy and parsing the screen, in order to save and create storable versions of our composition pane. In this design, we use system features and the FileChooser, as well as additional Observable features in order to pattern these new abilities into the program. These are nicely represented and create a succinct class to handle and manage these compositions in the context of them being storages files on a computer. We also expand the previous Observables to handle disabling of these new menu items.

## Elegance:
 Our solution is elegant becasue we actively thought about the principles and guidelines we have been learning about while writing our program so that it would be as elegant as possible. We applied the SOLID principles in the places mentioned in the seciton above. 

Another aspect that makes our program elegant is the ActionObserver that we implemented. Since we implemented all the actions with the abstract Action class, we were able to make a ActionObserver that contains Stacks of the undo-able actions and stores them instead of holding complete states of the composition pane which would involve holding information about many different types of objects.

In this new project, the implimentation of FileManager as an additional Obervable class once again succintly handles disabling as well as inplimenting the FileChooser methods and parsing which create/store/handle files.

After learning this week, we beleive that our attention to patterning has been an elegent approach, which uses versions or loose models of the Command pattern (called the action class in this reflection's description) and singleton patterns. Without having learned previously, our implimentation was a natural occurance which elegantly introduces patterning to our code and helps in robustness and scalability. We also beleive our abstraction and many classes are now becoming further elegent because they have expanded to the point that we only change a few classes on each project, and are able to leave many untouched and no longer work or care about those portions. This has led to the amount of code we are actually handling being minimal and allows easy changing since each attempt has limited reachability or ability to affect unrelated functional requirements. We also use Observable patterns which elegantly impliment disabling.

## Inelegance:
 Some aspects that make our solution inelegant are that MouseEvents handle too much, there is a lot of coupling of classes, and NoteBar has too much responsibility. The MouseEvent handlers have too much responsibility and a small change in the program could require us to make significant changes to these handlers. The way we have written the handlers would make these changes difficult to implement. The coupling of classes is caused by a significant reliance between classes. For example, classes that have controllers are coupled with their controllers in a way that would make it difficult to make large modifications without going through both the class and its controller class and making all the necessary modifications. We did not have time to fix these sources of inelegance because of our initial attempts to make a major refactoring to the previous project. 
 
A new addition of inelegance is creating our own version of an XML parser. This was done after our conversation with you prompted the notification to the class to use built versions of the same thing. This also was because of a fruitless search for good online documentation of an existant version. This is ineligant because it rebuilds system features unneccessarily, and without standardization to XML or JSON. In project 8, we continue to reinvent the wheel and use our version of parsing which is additional complications beyond the needs of the project.

As noted by you, it violates Liskov Substitution Principle that CopyAction has undo and redo when not possible, though when approaching solving this, we could not find a better way to pattern it's implimentation as a seperate and different action type. In a different version, making save, etc. actions and making these actions extend UndoableAction and Action extend to these two types may make more sense.

## Time Spent:
 As a team we spent about 30 hours. We estimated that we would have about 70 story points for this project where 5 points was our base for a moderately simple implementation. Our velocity then was about 2.3 storypoints/hour, which is a large increase (about an additional storypoint per hour!) The ratio of points/person-hour is 2.3:1. I think this is because our planning and estimation skills, especially in the context of this project, are greatly increasing as we continue working.

## Team:
 Our team has continued to work really well with each other. We have a group iMessage where we communicate about meeting times and update each other on individual efforts to fix bugs or make changes and also update each other on personal accomplishments. In our first meeting of the project we told each other our highlights of the day, to add some personalization to our team. We also communicated well on discussing our design and how we wanted to go about completing this project. In this project, we used planning poker and storyboarding to create target storypoints and estimate the number of days and time needed to get each task done. This was made more difficult because of our busy schedules and other classes and exams, but if anything this meant it was more important to plan ahead. We were much stricter about these deadlines, as a result, we finished much earlier than previous rounds and had much better understandings of our responsibilities. In addition to our own coding, we also problem solved and helped one-another, as well as testing and finding bugs and addressing refactoring. We had a cycle where everyone would review an assigned set of classes and once one person had reviewed them, another person would review them again. We will continue to communicate well and use this strategy of double checking our classes. We all have really appreciated each other's work, effort and commitment. I am keeping this section the same from Project 7 to 8, because our methods worked well, we tweaked only slight things in our team process. The only addition was that this round included more paried programming given the assignments nest and closely related nature, which led to needing to work in tandem.
